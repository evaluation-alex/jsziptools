{"name":"Jsziptools","tagline":"zip utility implemented with JavaScript","body":"# jsziptools\r\n\r\nIt's a utility of zlib, gzip and zip format binary data.\r\n\r\n## suported browser\r\n\r\nchrome, firefox, IE10, safari, opera.\r\n\r\n## examples\r\n\r\n### web examples\r\n\r\n* [Deflate text](http://ukyo.github.com/jsziptools/examples/deflate_text.html)\r\n* [Zip viewer](http://ukyo.github.com/jsziptools/examples/zip_viewer.html)\r\n\r\n## APIs\r\n\r\nIf the api is written as *foo({a, b, c})*, you can call it as below.\r\n\r\n```js\r\nfoo(1, 2, 3);\r\nfoo({\r\n  a: 1,\r\n  b: 2,\r\n  c: 3\r\n});\r\n```\r\n\r\n### Promise\r\n\r\njsziptools uses ES6 Promises and add `spread` method.\r\n\r\n### Promise.prototype.spread(onFulfillment, onRejection)\r\n\r\n* @param {function} onFulfillment\r\n* @param {function} onRejection - optional\r\n* @return {Promise}\r\n\r\nIt spreads a Array argument in a `onFulfillment` callback. \r\n\r\n```js\r\n// in ES6 Promises then\r\nPromise.all([1, 2, 3]).then(function (args) {\r\n  var one = args[0], two = args[1], three = args[2];\r\n});\r\n\r\n// in Promise.prototype.spread\r\nPromise.all([1, 2, 3]).spread(function (one, two, three) {\r\n  // ...\r\n});\r\n```\r\n\r\n### utils\r\n\r\n#### jz.utils.toBytes(buffer)\r\n\r\n* @param {ArrayBuffer|Uint8Array|Array|string} buffer\r\n* @return {Uint8Array}\r\n\r\n#### jz.utils.readFileAsArrayBuffer(blob)\r\n\r\n* @param {Blob} blob\r\n* @return {Promise}\r\n\r\n```js\r\njz.utils.readFileAsArrayBuffer(blob)\r\n.then(function (buffer) {\r\n  // ...\r\n});\r\n```\r\n\r\n#### jz.utils.readFileAsText(blob, encoding)\r\n\r\n* @param {Blob} blob\r\n* @param {string} encoding - optional (default is `\"UTF-8\"`)\r\n* @return {Promise}\r\n\r\n#### jz.utils.readFileAsDataURL(blob)\r\n\r\n* @param {Blob} blob\r\n* @return {Promise}\r\n\r\n#### jz.utils.readFileAsBinaryString(blob)\r\n\r\n* @param {Blob} blob\r\n* @return {Promise}\r\n\r\n#### jz.utils.bytesToString(buffer)\r\n\r\n* @param {Uint8Array|ArrayBuffer|Array|string} buffer\r\n* @return {Promise}\r\n\r\n```js\r\njz.utils.bytesToString(bytes)\r\n.then(function (str) {\r\n  // ...\r\n});\r\n```\r\n\r\n#### jz.utils.concatBytes(buffers)\r\n\r\n* @param {Array.\\<Uint8Array|ArrayBuffer\\>} buffers\r\n* @return {Uint8Array}\r\n\r\n```js\r\nvar concated = jz.utils.concatBytes([bytes1, bytes2]);\r\n// or\r\nvar concated = jz.utils.concatBytes(bytes1, bytes2);\r\n```\r\n\r\n#### jz.utils.load(urls)\r\n\r\nIt loads files as `Uint8Array`.\r\n\r\n* @param {Array.\\<string\\>} urls\r\n* @return {Promise}\r\n\r\n```js\r\njz.utils.load(['foo.png', 'bar.jpg'])\r\n.spread(function (foo, bar) {\r\n  // ...\r\n});\r\n// or\r\njz.utils.load('foo.png', 'bar.jpg')\r\n.spread(function (foo, bar) {\r\n  // ...\r\n});\r\n```\r\n\r\n### algos\r\n\r\n#### jz.algos.deflate({buffer, level, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number} level - optional (default is `6`, range is 0-9)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Uint8Array}\r\n\r\n#### jz.algos.inflate({buffer, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Uint8Array}\r\n\r\n#### jz.algos.adler32(buffer)\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @return {number}\r\n\r\n#### jz.algos.crc32({buffer, crc})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number}\r\n* @return {number}\r\n\r\n#### jz.stream.algos.deflate({buffer, streamFn, level, shareMemory, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {number} level - optional (default is `6`)\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n\r\n```js\r\njz.stream.algos.deflate({\r\n  buffer: buffer,\r\n  streamFn: function (chunk) {\r\n    // ...\r\n  },\r\n  shareMemory: false\r\n});\r\n```\r\n\r\n#### jz.steram.algos.inflate({buffer, streamFn, shareMemory, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n\r\n### zlib\r\n\r\n#### jz.zlib.compress({buffer, level, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number} level - optional (default is `6`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Uint8Array}\r\n\r\n#### jz.zlib.decompress({buffer, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Uint8Array}\r\n\r\n#### jz.stream.zlib.compress({buffer, streamFn, level, shareMemory, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {number} level - optional (default is `6`)\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n\r\n#### jz.stream.zlib.decompress({buffer, streamFn, shareMemory, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n\r\n### gzip\r\n\r\n#### jz.gz.compress({buffer, level, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number} level - optional (default is `6`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Uint8Array}\r\n\r\n#### jz.gz.decompress({buffer, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Uint8Array}\r\n\r\n#### jz.stream.gz.compress({buffer, streamFn, level, shareMemory, chunkSize, fname, fcomment})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {number} level - optional (default is `6`)\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @param {string} fname - optional\r\n* @param {string} fcomment - optional\r\n\r\n#### jz.stream.gz.decompress({buffer, streamFn, shareMemory, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer} buffer\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n\r\n### zip\r\n\r\n#### jz.zip.pack({files, level, chunkSize})\r\n\r\n* @param {Array.<object>} files\r\n* @param {number} level - optional (default is `6`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Promise}\r\n\r\n```js\r\nvar files = [\r\n  {name: \"foo\", dir: [ // folder\r\n    {name: \"hello.txt\", buffer: \"Hello World!\"}, // string\r\n    {name: \"bar.js\", buffer: buffer}, // ArrayBuffer\r\n    {name: \"hoge.mp3\", url: \"audiodata/hoge.mp3\"} // xhr\r\n  ]}\r\n];\r\n\r\njz.zip.pack({\r\n  files: files,\r\n  level: 5\r\n})\r\n.then(function (buffer) {\r\n  // buffer is Uint8Array\r\n});\r\n\r\n\r\n// You cat set compression level to each files.\r\nvar files = [\r\n  {name: \"mimetype\", buffer: \"application/epub+zip\", level: 0}, //string\r\n  {name: \"META-INF\", dir: [ //folder\r\n    {name: \"container.xml\", buffer: buffer, level: 0}, //ArrayBuffer\r\n  ]},\r\n  {name: \"package.opf\", url: \"package.opf\", level: 6},\r\n  {name: \"foo.xhtml\", url: \"foo.xhtml\", level: 9} //xhr\r\n];\r\n\r\njz.zip.pack(files)\r\n.then(function (buffer) {\r\n  // ...\r\n});\r\n```\r\n\r\n#### jz.zip.unpack({buffer, encoding, chunkSize})\r\n\r\n* @param {Uint8Array|ArrayBuffer|Blob} buffer\r\n* @param {string} encoding - optional (default is `\"UTF-8\"`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Promise}\r\n\r\n```js\r\njz.zip.unpack({\r\n  buffer: buffer,\r\n  encoding: 'Shift_JIS' // encoding of filenames\r\n})\r\n.then(function (reader) {\r\n  // reader is ZipArchiveReader. See below.\r\n  // get file names.\r\n  reader.getFileNames();\r\n  reader.readFileAsText(reader.getFileNames[0])\r\n  .then(function (text) {\r\n    // ...\r\n  });\r\n});\r\n```\r\n\r\n#### jz.stream.zip.pack({files, streamFn, level, shareMemory, chunkSize})\r\n\r\n* @param {Array} files\r\n* @param {function(chunk: Uint8Array)} streamFn\r\n* @param {number} level - optional (default is `6`)\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n* @return {Promise}\r\n\r\n```js\r\njz.stream.zip.pack({\r\n  files: files,\r\n  streamFn: function (chunk) {\r\n    // ...\r\n  }\r\n})\r\n.then(function () {\r\n  // no args\r\n});\r\n```\r\n\r\n### ZipArchiveReader\r\n\r\n#### ZipArchiveReader#getFileNames()\r\n\r\nIt gets filenames in the zip archive.\r\n\r\n* @return {Array.\\<string\\>}\r\n\r\n#### ZipArchiveReader#readFileAsArrayBuffer(filename)\r\n\r\n* @param {string} filename\r\n* @return {Promise}\r\n\r\n#### ZipArchiveReader#readFileAsBlob(filename)\r\n\r\n* @param {string} filename\r\n* @return {Promise}\r\n\r\n#### ZipArchiveReader#readFileAsText(filename, encoding)\r\n\r\n* @param {string} filename\r\n* @param {string} encoding\r\n* @return {Promise}\r\n\r\n#### ZipArchiveReader#readFileAsDataURL(filename)\r\n\r\n* @param {string} filename\r\n* @return {Promise}\r\n\r\n#### ZipArchiveReader#readFileAsBinaryString(filename)\r\n\r\n* @param {string} filename\r\n* @return {Promise}\r\n\r\n#### ZipArchiveReader#readFileAsArrayBufferSync(filename)\r\n\r\n* @param {string} filename\r\n* @return {ArrayBuffer}\r\n\r\n#### ZipArchiveReader#readFileAsBlobSync(filename)\r\n\r\n* @param {string} filename\r\n* @return {Blob}\r\n\r\n#### ZipArchiveReader#readFileAsTextSync(filename, encoding)\r\n\r\n* @param {string} filename\r\n* @param {string} encoding\r\n* @return {string}\r\n\r\n#### ZipArchiveReader#readFileAsBinaryStringSync(filename)\r\n\r\n* @param {string} filename\r\n* @return {string}\r\n\r\n#### ZipArchiveReader#readFileAsDataURLSync(filename)\r\n\r\n* @param {string} filename\r\n* @return {string}\r\n\r\n### jz.zip.ZipArchiveWriter({shareMemory, chunkSize})\r\n\r\nLow level zip archive writer.\r\n\r\n* @param {boolean} shareMemory - optional (default is `false`)\r\n* @param {number} chunkSize - optional (default is `0x8000`)\r\n\r\n```js\r\n var writer = new jz.zip.ZipArchiveWriter({shareMemory: true, chunkSize: 0xf000});\r\n writer\r\n .on('data', function(chunk) {\r\n   // chunk is Uint8Array.\r\n })\r\n .on('end', function() {\r\n   // ...\r\n });\r\n .write('foo/bar/baz.txt', buffer)\r\n .write('a.mp3', mp3Buff)\r\n .writeEnd();\r\n```\r\n\r\n#### #on(name, callback)\r\n\r\n* @param {string} name\r\n* @param {function} callback\r\n* @return {jz.zip.ZipArchiveWriter} this\r\n\r\n#### #write(path, buffer, level)\r\n\r\nWrite the file. Directories are created automatically.\r\n\r\n* @param {string} path\r\n* @param {Uint8Array} buffer\r\n* @param {number} level - optional (default is `6`)\r\n* @return {jz.zip.ZipArchiveWriter} this\r\n\r\n```js\r\nwriter.write('a/b/c/d/foo.txt', buffer, 7);\r\n```\r\n\r\n#### #writeDir(path)\r\n\r\n* @param {string} path\r\n* @return {jz.zip.ZipArchiveWriter} this\r\n\r\n```js\r\nwriter.writeDir('foo/');\r\n// or\r\nwriter.writeDir('bar');\r\n```\r\n\r\n#### #writeFile(path, buffer, level)\r\n\r\n* @param {string} path\r\n* @param {Uint8Array} buffer\r\n* @param {number} level - optional (default is `6`)\r\n* @return {jz.zip.ZipArchiveWriter} this\r\n\r\n```js\r\nwriter.writeDir('a/');\r\nwriter.writeDir('a/b/');\r\nwriter.writeDir('a/b/c/');\r\nwriter.writeFile('a/b/c/foo.txt', buffer, 7);\r\n```\r\n\r\n#### #writeEnd()\r\n\r\nWrite central directory headers and the end central dirctory header.\r\n\r\n```js\r\nwriter.writeEnd();\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}